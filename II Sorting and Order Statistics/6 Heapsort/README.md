## 堆排序  

### 最大堆  

思路：先考虑基本操作：`MaxHeapify`使某一个元素位于最大堆中的正确位置，通过比较该元素所在结点（根结点），以及其两个子结点的大小，将根结点元素与三个结点元素中的最大值交换，并递归进行，直到该元素无法再被交换，即到达了正确位置。  

之后考虑将数组变成最大堆，设置属性`heapSize`为数组长度，之后自底向上调用`maxHeapify`，构造最大堆。  

有了最大堆之后，可以考虑进行堆排序，即每一次都将堆中的第一个元素（最大堆的根结点）与堆中的最后一个元素调换，之后`heapSize - 1`，然后重新对最大堆进行整理，重复操作，直至`heapSize`为 1，排序完成。  

时间复杂度：`buildMaxHeap` - O(n)  

`maxHeapify` - O(lgn)  

`heapSort` - O(nlgn)  

循环不变式：在`buildMaxHeap`中，每一次循环前，结点`[i, n]`都是一个最大堆的根节点。  

代码：[Java](./MaxHeap.java) 然而完全不知道自己写的什么乱七八糟的东西…  

注意点：在`maxHeapify`中，要注意下标`left`和`right`都不能超过`heapSize`。  

### 书后练习  

#### 6.3-2  

考虑一个反例，a[0] = 0，a[1] = 1，a[3] = 3，如果从 1 递增，最终的结果是 a[0] = 1，a[1] = 3，a[3] = 0，仍然不符合最大堆的定义。  

