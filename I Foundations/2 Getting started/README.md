## 插入和归并排序  
### 插入排序  

思路：假设前 k 个元素已经排序完成，取出第 k+1 个元素作为 key，与前面 k 个元素逐一比较，找到正确的下标 i 之后，下标从 k 到 i 的元素依次向后移动，最后将 key 插入 i 的位置。  

时间复杂度：O(n^2)  

循环不变式：每次迭代前，数组前 k-1 个元素构成的子数组，就是原来数组中的前 k-1 个元素，但已经按序排列。  

代码：[C](./insertion_sort.cpp)、[java](./InsertionSort.java)  

### 归并排序  

思路：假设要排序的数组被分成了两个已经排好序的子数组，每一次都取出两个子数组中最小的元素进行比较，将其中更小的元素放入结果数组中，直到所有元素被遍历。递归实现上述过程。  

时间复杂度：O(nlgn)*  

循环不变式：在函数`merge`的`合并`操作过程中，每次迭代前，子数组`A[start, k-1]`都是按序排列的，且恰好是`left[len1+1]`和`right[len2+1]`中最小的 k-start 个元素。从而`left[]`和`right[]`的下一个元素是各自数组中最小的，没有被放入结果数组的元素。  

代码：[C](./merge_sort.cpp)、[java](./MergeSort.java)  

注意点：  
1. 用两个函数分别实现`递归`(mergeSort)和`合并`(merge)的操作。  
2. 合并两个子数组时，两个数组的最后都要有一个 `INT_MAX`，保证在进行最后一次比较时，数组下标不越界，并且所有元素都能被放入结果数组。同时应该注意到，在声明数组时，数组长度为`len + 1`，在最后插入 `INT_MAX` 时，数组下标是`len`。  
3. `mergeSort`中的判断条件是必要的，保证了递归会有一个终点。  
4. 注意`merge`和`mergeSort`的参数 `start` `middle` `end` 都是相对的，即传入的数组可能是原数组中间某一段的子数组，**对下标做运算时不能引入`n`或`0`这样的绝对数值**。  

思考：本质上是一个不断二分，再逐级上升的过程。  

相关练习： 
<table>
<tr>
<th>题目</th>
<th>答案</th>
</tr>
<tr>
<th><a href="https://leetcode-cn.com/problems/shuffle-string/">leetcode 1528</a></th>
<th><a href="./RestoreString.java">java</a></th>
</tr>
</table>  

*对数函数以 2 为底，lgn 的意义是 n 的二进制长度  

### 比较  

显然，当 n 足够大时，归并排序的速度远大于插入排序；n 较小或数组已经按序排好时，插入排序更有优势。  