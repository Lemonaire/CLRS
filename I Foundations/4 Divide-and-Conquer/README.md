## 分治策略  

### 最大子数组问题  

#### 暴力求解  

思路：略  

时间复杂度：O(n^2)  

代码：[Java](./MaxSubarray.java)  

#### 分治方法  

思路：考虑最大子数组一定是`A[start, mid]`的子数组，`A[mid+1, end]`的子数组，或跨越中点的某一个子数组，对于前两种情况，进行递归，对于第三种情况，考虑所有形如`A[i, mid]`，`A[mid+1, j]`的子数组，对左右两端分别取最大值，合并后必为最大值。  

时间复杂度：O(nlgn)  

循环不变式：不知道 qwq  

代码：[Java](./MaxSubarray.java)  

注意点：在`findMaxSubarray`中，最后的大小比较，判断条件中需要带等号，否则当出现左右和相等且都为最大子数组时，前两个情况都不满足，出现错误结果。  

思考：`findMaxSubarray`的基本情况是左右下标相等，保证了当数组中出现一个极大数时，会一直返回这个数。当最大子数组的长度 >= 2 时，必定会二分到一个数组，使最大子数组跨越中点，从而得到返回值。  

#### 书后练习  

##### 4.1-1  

返回最大的数的位置和值  

##### 4.1-2  

代码见上文暴力求解代码  

### 矩阵乘法  

#### 直接分治递归  

思路：把`n * n`的矩阵分解成 4 个`n/2 * n/2`的矩阵，根据分块矩阵的性质，可以递归地计算四个分块矩阵的乘积。  

时间复杂度：O(n^3)  

循环不变式：也不知道（  

代码：[Java](./SquareMatrixMultiply.java)  

思考：实际上，伪代码中另一个省略的关键点是如何兼容非方阵的矩阵，如果不能正确处理这类矩阵，会导致数组下标越界，或阶数不为`2^n`的方阵相乘计算结果错误。  

注意点：尽管对复杂度没有影响，但拆分矩阵时应该传入矩阵下标作为参数，而不是复制矩阵（这会产生`Θ(n^2)`的消耗）。由于 Java 传递数组时传入的是引用，因此直接在修改数组值即可，无需返回新数组。  

#### Strassen 算法

思路：把`n * n`的矩阵分解成 4 个`n/2 * n/2`的矩阵，将四个分块矩阵的乘积分解成一系列`n/2 * n/2`的矩阵的和差积，递归计算。  

时间复杂度：O(n^lg7)  

循环不变式：还是不知道…  

伪代码：不会写 qwq  

代码：逃课了  